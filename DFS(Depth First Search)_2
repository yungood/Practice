#include<iostream>
using namespace std;


/*  깊이 우선 탐색법(DFS - Depth First Search)

	Q2 > 출발점메서 도착점으로 오는 모든 경로의 개수를 출력 + 최단 경로의 길이 출력
		(좌측 상단(0,0)이고 우측 하단(4,4)인 5짜리 배열)

		입력 데이터) 5
					 1 1 1 0 0
					 0 0 1 1 1
					 1 1 1 0 1
					 1 0 0 0 1
					 1 1 1 1 1

*/

int n, cnt;
int len = 1, min = 0; // km  = 경로길이 구하기 (시작점(0,0)을 경로길이에 포함하고 시작), min = 최단경로길이
int a[5][5];


void DFS(int y, int x) {
	

	// 마지막 도착(위치) 지점에 도달하면 경로 개수 1 증가, 종료 조건
	if (y == n-1 && x == n-1) {
		
		cnt++;

		if (cnt == 1) { // 첫 경로의 길이를 구해서 min에 저장
			min = len;
		}
		else {  // 첫 경로 이후의 길이를 구하여 현재 최소길이와 비교하여 더 작은 길이로 변경해줌
			if (len < min) {
				min = len;
			}
			
		}

		return;
	}

	len++; // DFS()함수 부를때마다 경로길이 1씩 증가(함수를 부른다는 것은 다음경로로 이동했다는 얘기이므로)
	a[y][x] = 0; // 다시 방문하지 않도록 0으로 일시적으로 바꿈

	// 위쪽으로 방문
	if (y > 0 && a[y - 1][x] == 1) {
		DFS(y - 1, x);
	}
	// 아래쪽으로 방문
	if (y < n-1 && a[y+1][x] == 1) {
		DFS(y+1, x); 
	}
	// 왼쪽으로 방문
	if (x > 0 && a[y][x-1] == 1) { 
		DFS(y, x-1); 
	}
	// 오른쪽으로 방문
	if (x < n-1 && a[y][x+1] == 1) { 
		DFS(y, x+1); 
	}
  
	len--; // 길이도 다시 처음으로 리셋(len = 1로 원상복구)
	a[y][x] = 1; // 1로 다시 복원(모든 경로를 찾아야하므로)(잠시 0으로 만들었던 길들을 다시 1로 복원해준다.)
	
}


int main(){

	cin >> n;

	int i, j;

	for (i = 0; i < n; i++) {
		for (j = 0; j < n; j++) {
			cin >> a[i][j];
		}
	}

	DFS(0, 0);

	cout <<"모든 경로 : " <<cnt << "\n" <<"모든 경로 중 최단 길이 : " << min << "\n";

	return 0;		
}
