#include<iostream>
#include<math.h> //sqrt 사용위해

using namespace std;

#define N 101


/*
	에라토스테네스의 체(Eratosthenes' sieve) : 임의의 자연수에 대하여, 그 자연수 이하의 소수를 모두 찾아주는 방법.

	(1) 1부터 n까지의 자연수를 전부 나열한다.
	(2) 소수도, 합성수도 아닌 1을 지운다.
	(3) 남아있는 자연수 중 가장 작은 수인 2를 소수다. 이제 2의 배수들을 모두 지운다,
	(4) 남아있는 자연수 중 가장 작은 수인 3은 소수다. 이제 3의 배수들을 모두 지운다.
	(5) 남아있는 자연수 중 가장 작은 수는 소수다. 이 수의 배수들을 모두 지운다.
	(6) 남아있는 자연수 중 가장 작은 수가 n의 제곱근을 넘기전까지 과정 5를 반복하면, 남아있는 수가 모두 소수다.


	EX. 에라토스테네스의 체를 사용하여 100이하의 소수를 찾아보자.
	    설명) 100의 제곱근은 10, 남아있는 가장 작은 소수가 10보다 커지기 전까지만 지원나가는 과정을 반복하면 된다.
		      즉 7의 배수까지만 생각하면 된다.
			  7의 배수까지 이 과정을 반복한 후 남아있는 자연수들인 '2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97'이 100이하의 소수들이다.
	      

*/


int main() {

	int number[N] = {0}; // 1 ~ 100 자연수 저장
	int s = 0; // N(100)의 제곱근
	int j = 2; // 자연수들의 배수 구할떄 증가값으로 사용(2,3,4,5,6....)
	int i = 0;

	// 1~100까지 정수 저장
	for (i = 1; i < N; i++) {
		number[i] = i;
	}

	s = sqrt(100); // N(100)의 제곱근

	for (i = 1; i < s; i++) {
		
		if (i == 1) {  // 자연수 1은 소수도 합성수도 아니다.
			number[i] = 0;
		}

		if ( i == 2) {  // 소수들 중 유일하게 짝수
			while ( i * j < N) {
				number[i * j] = 0;
				j++;			
			}
			j = 2;
		}

		// i가 홀수이면
		if (i % 2 == 1) {
			for (int k = 2; k < i; k++) {
				if (i % k == 0) { //  i가 소수가 아니므로
					break;
				}
				else {  // i가 소수이면
					while (i * j < N) {
						number[i * j] = 0;
						j++;
					}
					j = 2;
				}
			}
		}

	}

	// 100이하의 소수들 출력
	for (i = 1; i < N; i++) {
		if (number[i] != 0) {
			cout << i << "\n";
		}
	}


	return 0;

}
